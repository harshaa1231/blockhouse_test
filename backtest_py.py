# -*- coding: utf-8 -*-
"""backtest.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1shvD0wHdLB3pBaCCtuwpC2-5gcaeAXsX
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import json

TOTAL_SHARES = 5000
STEP = 100
DATA_FILE = "l1_day.csv"

def load_data(file_path):
    df = pd.read_csv(file_path)
    df.sort_values(['ts_event', 'publisher_id'], inplace=True)
    df = df.drop_duplicates(subset=['ts_event', 'publisher_id'], keep='first')
    return df

def compute_cost(split, venues, order_size, lambda_over, lambda_under, theta_queue):
    executed = 0
    cash_spent = 0
    for i in range(len(venues)):
        exe = min(split[i], venues[i]['ask_size'])
        executed += exe
        cash_spent += exe * (venues[i]['ask'] + venues[i]['fee'])
        maker_rebate = max(split[i] - exe, 0) * venues[i]['rebate']
        cash_spent -= maker_rebate
    underfill = max(order_size - executed, 0)
    overfill = max(executed - order_size, 0)
    risk_pen = theta_queue * (underfill + overfill)
    cost_pen = lambda_under * underfill + lambda_over * overfill
    return cash_spent + risk_pen + cost_pen

def static_allocator(snapshot, lambda_over, lambda_under, theta_queue):
    venues = []
    for _, row in snapshot.iterrows():
        venues.append({
            'ask': float(row['ask_px_00']),
            'ask_size': int(row['ask_sz_00']),
            'fee': 0.0,
            'rebate': 0.0
        })
    splits = [[]]
    for v in range(len(venues)):
        new_splits = []
        for alloc in splits:
            used = sum(alloc)
            max_v = min(TOTAL_SHARES - used, venues[v]['ask_size'])
            for q in range(0, max_v + 1, STEP):
                new_splits.append(alloc + [q])
        splits = new_splits
    best_cost = float('inf')
    best_split = [0] * len(venues)
    for alloc in splits:
        if sum(alloc) != TOTAL_SHARES:
            continue
        cost = compute_cost(alloc, venues, TOTAL_SHARES, lambda_over, lambda_under, theta_queue)
        if cost < best_cost:
            best_cost = cost
            best_split = alloc
    split_dict = {}
    for idx, publisher_id in enumerate(snapshot['publisher_id'].values):
        split_dict[publisher_id] = best_split[idx] if idx < len(best_split) else 0
    return split_dict

def run_strategy(df, strategy_func, pass_shares=False, **kwargs):
    total_cash = 0
    shares_remaining = TOTAL_SHARES
    cost_progression = []
    for ts in df['ts_event'].unique():
        snapshot = df[df['ts_event'] == ts]
        if shares_remaining <= 0:
            break
        if pass_shares:
            allocation = strategy_func(snapshot, shares_remaining, **kwargs)
        else:
            allocation = strategy_func(snapshot, **kwargs)
        for venue_id, alloc in allocation.items():
            venue = snapshot[snapshot['publisher_id'] == venue_id]
            if venue.empty:
                continue
            ask_px = float(venue['ask_px_00'].values[0])
            ask_sz = int(venue['ask_sz_00'].values[0])
            fill_qty = min(alloc, ask_sz, shares_remaining)
            total_cash += fill_qty * ask_px
            shares_remaining -= fill_qty
            cost_progression.append(total_cash)
            if shares_remaining <= 0:
                break
    avg_price = total_cash / TOTAL_SHARES
    return total_cash, avg_price, cost_progression

def best_ask_strategy(snapshot, shares_remaining, **kwargs):
    venue = snapshot.loc[snapshot['ask_px_00'].idxmin()]
    return {venue['publisher_id']: shares_remaining}

def twap_strategy(snapshot, shares_remaining, **kwargs):
    venue_ids = snapshot['publisher_id'].unique()
    share_per_venue = shares_remaining // len(venue_ids)
    return {vid: share_per_venue for vid in venue_ids}

def vwap_strategy(snapshot, shares_remaining, **kwargs):
    snapshot = snapshot.copy()
    snapshot['weight'] = snapshot['ask_sz_00']
    total_weight = snapshot['weight'].sum()
    alloc = {}
    for _, row in snapshot.iterrows():
        weight_fraction = row['weight'] / total_weight
        alloc[row['publisher_id']] = int(weight_fraction * shares_remaining)
    return alloc

def search_and_run(df):
    best_result = None
    best_params = {}
    for lo in [0.1, 0.5, 1.0]:
        for lu in [0.1, 0.5, 1.0]:
            for tq in [0.1, 0.5, 1.0]:
                result, avg_price, progression = run_strategy(
                    df, static_allocator, pass_shares=False,
                    lambda_over=lo, lambda_under=lu, theta_queue=tq
                )
                if best_result is None or result < best_result:
                    best_result = result
                    best_params = {
                        "lambda_over": lo,
                        "lambda_under": lu,
                        "theta_queue": tq,
                        "total_cash_spent": result,
                        "average_fill_price": avg_price,
                        "progression": progression
                    }
    return best_params

if __name__ == "__main__":
    df = load_data(DATA_FILE)
    smart_result = search_and_run(df)
    best_result, best_price, best_prog = run_strategy(df, best_ask_strategy, pass_shares=True)
    twap_result, twap_price, twap_prog = run_strategy(df, twap_strategy, pass_shares=True)
    vwap_result, vwap_price, vwap_prog = run_strategy(df, vwap_strategy, pass_shares=True)

    savings_best = (best_price - smart_result["average_fill_price"]) / best_price * 10000
    savings_twap = (twap_price - smart_result["average_fill_price"]) / twap_price * 10000
    savings_vwap = (vwap_price - smart_result["average_fill_price"]) / vwap_price * 10000

    output = {
        "best_parameters": {
            "lambda_over": smart_result["lambda_over"],
            "lambda_under": smart_result["lambda_under"],
            "theta_queue": smart_result["theta_queue"]
        },
        "smart_order": {
            "total_cash_spent": smart_result["total_cash_spent"],
            "average_fill_price": smart_result["average_fill_price"]
        },
        "baselines": {
            "best_ask": {
                "total_cash_spent": best_result,
                "average_fill_price": best_price
            },
            "twap": {
                "total_cash_spent": twap_result,
                "average_fill_price": twap_price
            },
            "vwap": {
                "total_cash_spent": vwap_result,
                "average_fill_price": vwap_price
            }
        },
        "savings_vs_baselines_bps": {
            "best_ask": savings_best,
            "twap": savings_twap,
            "vwap": savings_vwap
        }
    }

    with open("results.json", "w") as f:
        json.dump(output, f, indent=2)

    plt.figure(figsize=(10, 6))
    plt.plot(smart_result["progression"], label="Smart Order Router")
    plt.plot(best_prog, label="Best Ask")
    plt.plot(twap_prog, label="TWAP")
    plt.plot(vwap_prog, label="VWAP")
    plt.title("Cumulative Cost Comparison")
    plt.xlabel("Execution Steps")
    plt.ylabel("Cumulative Cash Spent")
    plt.legend()
    plt.tight_layout()
    plt.savefig("results.png")

# Prepare data for bar chart comparison
strategies = ["Smart Router", "Best Ask", "TWAP", "VWAP"]
avg_prices = [
    smart_result["average_fill_price"],
    best_price,
    twap_price,
    vwap_price
]

# Bar Plot: Average Fill Prices
plt.figure(figsize=(8, 5))
bars = plt.bar(strategies, avg_prices, color=['steelblue', 'orange', 'green', 'red'])
plt.title("Average Fill Price Comparison")
plt.ylabel("Average Fill Price ($)")
plt.grid(axis='y', linestyle='--', alpha=0.7)

# Annotate bars with values
for bar in bars:
    yval = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2, yval + 0.1, f"{yval:.2f}", ha='center', va='bottom')

plt.tight_layout()
plt.show()

